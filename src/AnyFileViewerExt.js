import { ABCWidgetFactory, DocumentModel } from '@jupyterlab/docregistry';
import { Dialog, showErrorMessage } from '@jupyterlab/apputils';
import { Widget } from '@lumino/widgets';
import { requestAPI } from './handler';
import { findFirefly } from './FireflyCommonUtils.js';
import { SLATE_CMD_ID } from './SlateCommandExt.js';


export const ANYFACTORY = 'Firefly Viewer'; // name that appears in JL "Open With" menu
const NO_OP_ERROR = 'NoOpDocWidgetOpen';
const SUPPORTED_TYPES = {
	FITS: ['.fits', '.fits.gz', '.fits.zip'],
    Region: ['.reg'],
	VOTable: ['.vot', '.xml'],
    Parquet: ['.parquet'],
	IPACTable: ['.tbl'],
	csv: ['.csv'], // lower-case to override default CSV viewer
	tsv: ['.tsv'], // lower-case to override default TSV viewer
};

/**
 * Activate the AnyFileViewer extension.
 *
 * @param {JupyterLab} app
 * @param {ILayoutRestorer} _restorer
 */
export function activateAnyFileViewerExt(app, _restorer) {
	// Register supported file types
	Object.entries(SUPPORTED_TYPES).forEach(([name, extensions]) => {
		app.docRegistry.addFileType({
            name,
            displayName: `${name} file`,
            extensions,
            // mimeTypes can be added here if needed later
        });
	});

	// Register a minimal no-load model to avoid fetching/decoding large file content on the client
	const nullModelFactory = new FireflyNullModelFactory();
	app.docRegistry.addModelFactory(nullModelFactory);

	// Create a non-default reader that routes the file open event to Firefly's upload tab flow.
	// Use the custom 'firefly-null-model' so JL does not attempt to fetch/parse the file.
	const widgetFactory = new ABCWidgetFactory({
		name: ANYFACTORY,
		modelName: FireflyNullModelFactory.MODEL_NAME, // modelFactory to use
		fileTypes: Object.keys(SUPPORTED_TYPES),
		defaultFor: Object.keys(SUPPORTED_TYPES),
		readOnly: true
	});

	// JL expects createNewWidget to return a DocumentWidget for the file.
	// We instead forward the file to Firefly which uploads it to the Firefly server
	// and tells Firefly Viewer (client-side) to display it. So we fire
	// forwardToFirefly() and throw a No Op error to cancel JL's default open action.
	widgetFactory.createNewWidget = (context) => {
		void forwardToFirefly(app, context.path);

        // since we don't return a DocumentWidget, abort the normal open flow
		const err = new Error('Open DocumentWidget canceled by Any file viewer extension');
		err.name = NO_OP_ERROR;
		throw err;
	};
	app.docRegistry.addWidgetFactory(widgetFactory);

	// Suppress the expected No Op error in the console generated by createNewWidget()
    // (this is a workaround to remove noise from the console)
	if (!window.__fireflyCancelErrorHandlerInstalled) {
		const cancelHandler = (e) => {
			const err = e?.error;
			if (err && err.name === NO_OP_ERROR) {
				e.preventDefault();
				e.stopImmediatePropagation();
			}
		};
		window.addEventListener('error', cancelHandler, true);
		window.__fireflyCancelErrorHandlerInstalled = true; // flag to attach listener only once
	}
}

async function forwardToFirefly(app, filepath) {
    const filename = filepath.substring(filepath.lastIndexOf('/') + 1);

	// Create and show a non-blocking progress dialog
	const progressDialog = new Dialog({
		title: 'Firefly Viewer',
		body: `Uploading and opening "${filename}" in Fireflyâ€¦`,
		buttons: []
	});
	void progressDialog.launch();

	const handleFailure = (title, err) => {
		const msg = `${err?.message ?? err}`;
		console.error(`${title}:\n${msg}`);
		progressDialog.close();
		showErrorMessage(title, msg); // shows a error dialog in JupyterLab
	};

	// 1) Ensure Firefly Viewer is open/active (singleton behavior handled by SlateCommandExt)
	try {
		await app.commands.execute(SLATE_CMD_ID);
	} catch (e) {
		handleFailure('Failed to activate Firefly Viewer', e);
		return;
	}

	// 2) Upload file to Firefly server and get file's cache key
	let cacheKey;
	try {
        const responseText = await (await requestAPI(`sendToFirefly?path=${encodeURIComponent(filepath)}`)).text();
		if (!responseText?.startsWith('${')) {
            throw new Error(`Unexpected response from Firefly server: ${responseText}`);
        }
        cacheKey = responseText;
	} catch (e) {
		handleFailure('Upload to Firefly Failed', e);
		return;
	}

	// 3) Tell Firefly JS API to display the uploaded file
	try {
		const { firefly } = await findFirefly();
		firefly.action.dispatchExternalUpload({
			fileOnServer: cacheKey,
			immediate: false,
			displayName: filename
		});
	} catch (e) {
		handleFailure('Open in Firefly Failed', e);
		return;
	}
    
    console.debug('File forwarded to Firefly Viewer successfully: ', filepath);
	progressDialog.close();
}

// ---------------------------------------------------------------------
// Custom no-op document model and factory
// ---------------------------------------------------------------------

/**
 * A minimal document model that never loads or decodes file contents.
 * This is to avoid base64/text decoding for large binary files which
 * takes time and throws errors sometimes.
 */
class FireflyNullDocModel extends DocumentModel {
	constructor(options) {
		super(options);
		// Never mark dirty; we never edit this model
		this.dirty = false;
	}
	// Ignore incoming content completely
	fromString(_value) {}
	fromJSON(_value) {}
	// Provide empty content on save (should not be called since readOnly is true)
	toString() { return ''; }
	toJSON() { return null; }
}

class FireflyNullModelFactory {
	static MODEL_NAME = 'firefly-null-model';
	get name() { return FireflyNullModelFactory.MODEL_NAME; }
	// Treat as a generic file model
	get contentType() { return 'file'; }
	// Return null to indicate no content should be fetched for this model.
	get fileFormat() { return null; }
	// JupyterLab queries this for syntax highlighting; return empty/undefined is fine
	preferredLanguage(_path) { return ''; }
	get isDisposed() { return !!this._disposed; }
	get preferKernel() { return false; }
	get canStartKernel() { return false; }
	get collaborative() { return false; }
	dispose() { this._disposed = true; }
	createNew(options) { return new FireflyNullDocModel(options); }
}
