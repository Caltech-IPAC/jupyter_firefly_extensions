import { ABCWidgetFactory, DocumentWidget, DocumentModel } from '@jupyterlab/docregistry';
import { Widget } from '@lumino/widgets';
import { requestAPI } from './handler';
import { findFirefly } from './FireflyCommonUtils.js';

export const ANYFACTORY = 'Firefly Viewer';
const NO_OP_ERROR = 'NoOpDocWidgetOpen';

// TODO: extend to other file types as needed
const fitsFileType = {
	name: 'FITS',
	displayName: 'FITS file',
	fileFormat: null,
	contentType: 'file',
	mimeTypes: ['application/fits'],
	extensions: ['.fits']
};

/**
 * Activate the AnyFileViewer extension.
 *
 * @param {JupyterLab} app
 * @param {ILayoutRestorer} _restorer
 */
export function activateAnyFileViewerExt(app, _restorer) {
	// Ensure the file type exists (guard for duplicates)
	if (!app.docRegistry.getFileType('FITS')) {
		app.docRegistry.addFileType(fitsFileType);
	}

	// Register a minimal no-load model to avoid fetching/decoding large binary content on the client
	const nullModelFactory = new FireflyNullModelFactory();
	app.docRegistry.addModelFactory(nullModelFactory);

	// Create a non-default reader for FITS that routes to Firefly's generic show_data flow.
	// Use the custom 'firefly-null-model' so the context does not attempt to read/parse file content.
	const factory = new ABCWidgetFactory({
		name: ANYFACTORY,
		modelName: FireflyNullModelFactory.MODEL_NAME,
		fileTypes: ['FITS'],
		defaultFor: ['FITS'],
		readOnly: true
	});

	// JL expects createNewWidget to return a DocumentWidget for the file.
    // We instead forward the file to Firefly which uploads it to the Firefly server
    // and tells Firefly Viewer (client-side) to display it. So we fire
    // forwardToFirefly() and throw a No Op error.
	factory.createNewWidget = (context) => {
		void forwardToFirefly(app, context.path);

        // since we don't return a DocumentWidget, abort the normal open flow
		const err = new Error('Open DocumentWidget canceled by Any file viewer extension');
		err.name = NO_OP_ERROR;
		throw err;
	};
	app.docRegistry.addWidgetFactory(factory);

	// Suppress the expected No Op error in the console generated by createNewWidget()
	if (!window.__fireflyCancelErrorHandlerInstalled) {
		const cancelHandler = (e) => {
			const err = e?.error;
			if (err && err.name === NO_OP_ERROR) {
				e.preventDefault();
				e.stopImmediatePropagation();
			}
		};
		window.addEventListener('error', cancelHandler, true);
		window.__fireflyCancelErrorHandlerInstalled = true; // flag to attach listener only once
	}
}

async function forwardToFirefly(app, filepath) {
	// 1) Ensure Firefly Viewer is open/active (singleton behavior handled by SlateCommandExt)
	try {
		await app.commands.execute('firefly:open-slate');
	} catch (e) {
		console.error('Could not activate Firefly viewer:', e);
		return;
	}

	// 2) Upload file to Firefly server and get file's cache key
	let cacheKey;
	try {
        const responseText = await (await requestAPI(`sendToFirefly?path=${encodeURIComponent(filepath)}`)).text();
        if (!responseText?.startsWith('${')) {
            throw new Error(`Unexpected response from Firefly server: ${responseText}`);
        }
        cacheKey = responseText;
	} catch (e) {
		console.error('Error while uploading to Firefly server:', e);
		return;
	}

	// 3) Tell Firefly JS API to display the uploaded file
	try {
		const { firefly } = await findFirefly();
		firefly.action.dispatchExternalUpload({
			fileOnServer: cacheKey,
			immediate: false,
			displayName: filepath
		});
	} catch (e) {
		console.error('Error dispatching external upload to Firefly client:', e);
	}
    console.debug('File forwarded to Firefly Viewer successfully: ', filepath);
}

// ---------------------------------------------------------------------
// Custom no-op document model and factory
// ---------------------------------------------------------------------

/**
 * A minimal document model that never loads or decodes file contents.
 * This is to avoid base64/text decoding for large binary files which
 * takes time and throws errors sometimes.
 */
class FireflyNullDocModel extends DocumentModel {
	constructor(options) {
		super(options);
		// Never mark dirty; we never edit this model
		this.dirty = false;
	}
	// Ignore incoming content completely
	fromString(_value) {}
	fromJSON(_value) {}
	// Provide empty content on save (should not be called since readOnly is true)
	toString() { return ''; }
	toJSON() { return null; }
}

class FireflyNullModelFactory {
	static MODEL_NAME = 'firefly-null-model';
	get name() { return FireflyNullModelFactory.MODEL_NAME; }
	// Treat as a generic file model
	get contentType() { return 'file'; }
	// Return null to indicate no content should be fetched for this model.
	get fileFormat() { return null; }
	// JupyterLab queries this for syntax highlighting; return empty/undefined is fine
	preferredLanguage(_path) { return ''; }
	get isDisposed() { return !!this._disposed; }
	get preferKernel() { return false; }
	get canStartKernel() { return false; }
	get collaborative() { return false; }
	dispose() { this._disposed = true; }
	createNew(options) { return new FireflyNullDocModel(options); }
}
